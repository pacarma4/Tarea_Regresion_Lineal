---
title: "Modelos de regresión lineal simple y múltiple"
authors: "Pablo Carbonell Martínez y Pol Reig Gómez"
output: html_document
date: "2025-12-13"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Contexto de la tarea

En la librería MASS puedes encontrar un famoso banco de datos llamado Boston que contiene información
sobre 506 barrios de Boston, Massachusetts, en 1970. La base de datos contiene 14 variables relativas a
506 barrios. Para saber qué información está contenida en las variables puedes escribir ?Boston (después
de haber cargado la librería MASS).
En esta tarea trabajaremos con el conjunto de datos “boston.xlsx” que encontraréis en el aula virtual
(con 199 datos y 11 variables).

# Librerías

```{r}
library(readxl)
library(ggplot2)
library(corrplot)
```

# Carga del conjunto de datos Boston

```{r}
boston <- read_excel("boston.xlsx")

## Echamos un vistazo rápido
summary(boston)
```


# Ejercicio 1: Considera la variable respuesta crim relacionándola con la variable X con la que tenga mayor relación lineal.

## 1. Evalúa el efecto de X sobre crim, gráficamente y numéricamente. Es decir, indica como es la relación (fuerza y tipo).

```{r}
# Calculamos las correlaciones 
Correlaciones <- cor(boston)

# Evaluamos el efecto del resto de variables con crim numéricamente
print(Correlaciones[,"crim"])

# Y visualmente
corrplot(Correlaciones, method = "number")

print("Nuestra variable X es lstat")
```

## 2. Obtén la recta de mínimos cuadrados. Interpreta los resultados obtenidos (coeficientes, significatividad, R2, contraste del modelo, etc...).

```{r}
modelo <- lm(crim ~ lstat, data = boston)

summary(modelo)

# La recta ajustada es crim = -2.62305 + 0.42834·lstat, la cual indica una relación matemática entre el estatus de la población y la criminalidad.
# Como el valor de Pr(>|t|) es 3.86e-08, la variable es estadísticamente significativa. Por tanto, existe una relación lineal y significativa entre lstat y crim, y no es fruto del azar.
#La bondad del ajuste nos la da el valor de R^2, en nuestro caso tiene un valor de 40.85%.

```

## 3. Dibuja el diagrama de dispersión, la recta de regresión y las bandas de confianza al 90 %.

```{r}
ggplot(boston, aes(x = lstat, y = crim)) +
  geom_point(col = "blue", alpha = 0.6) +
  geom_smooth(method = "lm", level = 0.90, col = "red", fill= "green") + 
  labs(title = "Regresión Lineal: Crim vs Lstat", subtitle = "Bandas de confianza al 90%", x = "% poblacion de bajo estatus (lstat)", y = "Tasa de criminalidad (crim)")
```

## 4. Realiza un diagnóstico de los residuos. Si falla algunas de las condiciones, busca una (o varias) posible solución.

```{r}
par(mfrow = c(2,2))
plot(modelo)

modelo_log <- lm(log(crim) ~ lstat, data = boston)

summary(modelo_log)

plot(modelo_log)

# El diagnóstico muestra patrones claros de no linealidad y heterocedasticidad. Para solucionar esto, ajustamos un nuevo modelo utilizando el logaritmo de la tasa de criminalidad: log(crim) = -3.02416 + 0.17849·lstat. Esta transformación suaviza los valores extremos y mejora el ajuste a las hipótesis del modelo.
```

# Ejercicio 2: Considera la variable respuesta crim relacionándola con el predictor medv.

## 1. Evalúa el efecto de medv sobre crim.
```{r}
# Correlación numérica
cor_medv_crim <- cor(boston$crim, boston$medv)
cat("La correlación entre crim y medv es:", cor_medv_crim)

# Graficamos
ggplot(boston, aes(x = medv, y = crim)) +
  geom_point(alpha = 0.6) +
  labs(title = "Relación Crim vs Medv", x = "Valor mediano vivienda (medv)", y = "Criminalidad (crim)")

# La correlación es negativa: a mayor valor de la vivienda, menor criminalidad.
```

## 2. Obtén la recta de mínimos cuadrados. Interpreta los resultados obtenidos (coeficientes, significatividad, R2, contraste del modelo, etc...).
```{r}
modelo_medv <- lm(crim ~ medv, data = boston)
summary(modelo_medv)

cat("Recta ajustada: crim =", round(coef(modelo_medv)[1], 4), "+", round(coef(modelo_medv)[2], 4), "· medv\n")

# Interpretación:

# El p-valor (Pr(>|t|)) es menor a 0.05, la variable medv es significativa.

# Por cada 1000$ de aumento en el valor medio de viviendas, la tasa de criminalidad disminuye en -0.255.

# R2: El 26.99% de la variabilidad de la criminalidad explica el precio de la vivienda.

# Contraste global del modelo: F-statistic = 74.21 con p-valor = 2.2579e-15 -> modelo significativo
```

## 3. Dibuja el diagrama de dispersión, la recta de regresión y las bandas de predicción al 90 %.
```{r}
# Generamos los datos de las bandas de predicción
predicciones <- predict(modelo_medv, interval = "prediction", level = 0.90)
datos_plot <- cbind(boston, predicciones)

ggplot(datos_plot, aes(x = medv, y = crim)) +
  geom_point(color = "darkgrey") +
  geom_line(aes(y = lwr), color = "red", linetype = "dashed") + # Banda inferior
  geom_line(aes(y = upr), color = "red", linetype = "dashed") + # Banda superior
  geom_smooth(method = "lm", se = FALSE, color = "blue") +      # Recta de regresión
  labs(title = "Regresión con bandas de predicción (90%)",
       subtitle = "Crim vs Medv",
       x = "Medv", y = "Crim")
```

## 4. Realiza un análisis de los residuos.
```{r}
par(mfrow = c(2,2))
plot(modelo_medv)
par(mfrow = c(1,1))

# Observamos el gráfico "Residuals vs Fitted". Una forma de "U" o embudo, indica que el modelo lineal no es el ideal.
```

## 5. ¿Te parece adecuado haber realizado regresión lineal o es preferible otro tipo de regresión?. Ajusta el modelo que te parezca más adecuado.
```{r}
# Ajustamos un modelo log-lineal
modelo_medv_opt <- lm(log(crim) ~ medv, data = boston)
summary(modelo_medv_opt)

# Comparamos visualmente el ajuste
plot(boston$medv, log(boston$crim), pch=19, col="gray", main="Ajuste Log(Crim) vs Medv")
abline(modelo_medv_opt, col="blue", lwd=2)
```

## 6. ¿Qué tasa de criminalidad se espera para aquellos barrios con un precio mediano de la vivienda de 30000 dolares? ¿Y 10000? ¿Y 100000? Calcula e interpreta los intervalos de confianza y de predicción.
```{r}
# Valores a predecir (en miles de dólares)
nuevos_valores <- data.frame(medv = c(30, 10, 100)) 

# Predicción en escala logarítmica
pred_log_conf <- predict(modelo_medv_opt, newdata = nuevos_valores, interval = "confidence", level = 0.95)
pred_log_pred <- predict(modelo_medv_opt, newdata = nuevos_valores, interval = "prediction", level = 0.95)

# Deshacemos el logaritmo para interpretar en tasa de criminalidad real
res_conf <- exp(pred_log_conf)
res_pred <- exp(pred_log_pred)

print("Intervalos de Confianza (escala original):")
print(res_conf)
print("Intervalos de Predicción (escala original):")
print(res_pred)
```


# Ejercicio 3:

## 1. Encuentra el número óptimo de variables a incluir en un modelo predictivo de crim, según los criterios R2 , BIC y CP, utilizando la metodología RegSubsets. Indica brevemente en que consiste esta metodología. ¿Qué variables incluye el modelo obtenido? (Seleccionar el criterio que más os guste). Interpreta los coeficientes obtenidos. ¿Tienen todas sentido?. ¿Son significativos?.
```{r}
# Utilizamos la metodología RegSubsets para buscar el mejor subconjunto de predictores. Esta metodología prueba todas las combinaciones posibles de variables para encontrar la mejor según el tamaño del modelo.

library(leaps)

# Ejecutamos regsubsets
regfit_full <- regsubsets(crim ~ ., data = boston, nvmax = 11)
reg_summary <- summary(regfit_full)
print(reg_summary)

# Visualizamos los criterios
par(mfrow = c(1,3))
plot(reg_summary$cp, xlab = "Número de Variables", ylab = "Cp", type = "l", main = "Criterio Cp")
plot(reg_summary$bic, xlab = "Número de Variables", ylab = "BIC", type = "l", main = "Criterio BIC")
plot(reg_summary$adjr2, xlab = "Número de Variables", ylab = "R2 Ajustado", type = "l", main = "R2 Ajustado")

# Encontrar óptimos según cada criterio
opt_r2 <- which.max(reg_summary$adjr2)
opt_bic <- which.min(reg_summary$bic)
opt_cp <- which.min(reg_summary$cp)

cat("\nNÚMERO ÓPTIMO DE VARIABLES:\n")
cat("Según R² ajustado:", opt_r2, "variables\n")
cat("Según BIC:", opt_bic, "variables\n")
cat("Según Cp:", opt_cp, "variables\n")

# Interpretación: Observando los gráficos, elegimos el número de variables donde el BIC o Cp es mínimo, o donde el R^2 ajustado deja de crecer significativamente.

# Seleccionar modelo según BIC 
cat("\nModelo seleccionado: BIC \n")
coef_bic <- coef(regfit_full, opt_bic)
cat("Variables incluidas:", names(coef_bic)[-1], "\n")
cat("Coeficientes:\n")
print(coef_bic)

# Interpretación de coeficientes:
# Ejemplo: chas ->
# Manteniendo constantes las demás variables, por cada unidad de aumento en chas la tasa de criminalidad disminuye en 2.2648 unidades.
# Misma lógica para las otras variables (indus, rm, ptratio, lstat)

# Verificar significatividad ajustando el modelo completo
vars_modelo <- names(coef_bic)[-1]
formula_bic <- as.formula(paste("crim ~", paste(vars_modelo, collapse = " + ")))
modelo_bic <- lm(formula_bic, data = boston)
cat("\nSIGNIFICATIVIDAD DE LAS VARIABLES EN EL MODELO COMPLETO:\n")
print(summary(modelo_bic)$coefficients)

cat("\nTODAS SON SIGNIFICATIVAS\n")

# ¿Tienen sentido?
# Variables como lstat (% población bajo estatus) tienen relación positiva con crim, mientras que variables como chas (barrio cerca del río de Boston) tienen relación negativa con crim (los barrios frente al río tienen menor criminalidad). Esto tiene sentido, ya que cerca del río las casas son más caras.
```

## 2. Selecciona el mejor modelo con el método stepwise. Indica brevemente en que consiste esta metodología y contesta a las siguientes preguntas: ¿Qué modelo piensas que es mejor? (Entre este y el/los obtenido/s mediante Regsubsets). ¿Qué % de la varianza de crim explica el modelo? ¿Cuál es el efecto de la variable chas sobre crim?
```{r}
# El método stepwise agrega o elimina variables paso a paso basándose en un criterio (normalmente AIC). Es menos costoso que Regsubsets pero no garantiza encontrar el óptimo global.

modelo_full <- lm(crim ~ ., data = boston)

# Selección Stepwise
stepwise_model <- step(modelo_full, direction = "both", trace = 0) 
summary(stepwise_model)

# ¿Qué modelo es mejor?
cat("Comparación R² ajustado:\n")
cat("Regsubsets (BIC):", summary(modelo_bic)$adj.r.squared, "\n")
cat("Stepwise:", summary(stepwise_model)$adj.r.squared, "\n")

# El modelo Stepwise tiene un ligeramente mayor R^2 ajustado.

# ¿Qué porcentaje de varianza explica?
cat("\nR2 Ajustado:\n", summary(stepwise_model)$adj.r.squared)

# Efecto de la variable chas sobre crim
cat("\nVariable chas\n",coef(stepwise_model)["chas"])

# Su coeficiente indica cuánto cambia la criminalidad si el barrio está junto al río frente a si no lo está, manteniendo el resto de variables constantes.

```


## 3. Con el modelo obtenido con stepwise, realiza el diagnóstico de tu modelo, sin emprender ninguna acción, e indica los problemas que presenta.
```{r}
par(mfrow = c(2,2))
plot(step_model)
par(mfrow = c(1,1))

# No linealidad: El gráfico Residuals vs Fitted muestra una curva clara en forma de U, lo que indica que el modelo lineal simple no captura la estructura de los datos.

# No normalidad: El Q-Q Plot muestra una fuerte desviación en la cola superior, indicando que los residuos no se distribuyen normalmente.

# Heterocedasticidad: En el gráfico Scale-Location, la varianza de los residuos aumenta con los valores ajustados.
```


## 4. Emprende ahora las acciones que te parezcan oportunas e indica los problemas que has conseguido solucionar o mejorar un poco.
```{r}
# Dada la falta de linealidad, la heterocedasticidad y la no normalidad detectadas en el apartado anterior, procedemos a transformar la variable respuesta aplicando el logaritmo natural (log(crim))

# Modelo con log(crim)
modelo_log_full <- lm(log(crim) ~ ., data = boston)

# Nuevo stepwise sobre el modelo transformado
step_model_log <- step(modelo_log_full, direction = "both", trace = 0)
summary(step_model_log)

# Diagnóstico del nuevo modelo
par(mfrow = c(2,2))
plot(step_model_log)

# Mejoras:
# Linealidad (Residuals vs Fitted) -> línea roja mucho más horizontal y recta alrededor de 0.
# Normalidad (Q-Q Residuals) -> los puntos se ajustan mucho mejor a la diagonal.
# Homocedasticidad (Scale-Location) -> la dispersión de puntos es más uniforme y la línea roja es más plana.
```


## 5. Obtén la predicción de la tasa de criminalidad para un barrio en la mediana de los predictores en el modelo escogido. Notar que las variables categóricas se tratan de diferente manera, no hay mediana.

```{r}
# Crear el dato "mediano"
# Para variables numéricas usamos la mediana.
# En este dataset 'chas' es binaria (0/1), usamos la mediana.

nuevos_datos_media <- data.frame(t(sapply(boston, median)))

# Predecir con el modelo mejorado
pred_log_media <- predict(step_model_log, newdata = nuevos_datos_media, interval = "prediction")

# Transformar de vuelta
pred_final <- exp(pred_log_media)

print("Predicción de criminalidad para el barrio mediano:")
print(pred_final)
```

